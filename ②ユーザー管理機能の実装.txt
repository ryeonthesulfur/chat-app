【ユーザー管理機能の実装】

０．事前準備
１．deviseをインストール
２．Userモデルの作成
３．deviseのビュー用意
４．サインアップ・ログイン機能の実装
５．ユーザー情報編集機能の実装
６．ビューにリンクを実装
７．ログアウト機能の実装
８．バリデーション設定
９．GitHubで管理



０．事前準備

　・masterブランチ（mainブランチ）が最新になっていることを確認

　・ブランチを作成　➡　ブランチ名は「ユーザー管理機能の実装」とする。


１．deviseをインストール　※コミット名は「deviseのインストール」

　・ChatAppにGemのdeviseをインストールする。
　・Gemfileの一番下またはgroup群の上に「gem "devise"」と追記する。
　・ターミナルで「bundle install」する。
　・その後、「bundle exec rails generate devise:install」または、
　　　「rails g devise:install」とコマンドする。

　・以下、２つのファイルができていることを確認する
　　　「config/initializers/devise.rb」
　　　「config/locales/devise.en.yml」

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
＊＊bundle install の意味＊＊

「必要な部品（ライブラリ）を倉庫から取ってきて、アプリで使える状態にする」 作業です。

　・Gemfileに追記: 「このアプリでは devise という部品を使いたい！」と宣言するリスト作りです。

　・bundle install: そのリストを見て、インターネット上の倉庫（RubyGems）から
　　実際のプログラムをダウンロードし、自分のパソコンのアプリ環境に組み込みます。
　　　　「bundle update」した際、Using devise 5.0.2 と出ているのは、
　　　　この作業によって「デバイズという部品が準備できたよ！」という状態になったことを示しています。


＊＊「rails g devise:install」の意味＊＊

「買ってきた部品（Gem）を、自分のアプリに馴染むように初期設定する」 作業です。
bundle install をしただけでは、まだ devise というプログラムがフォルダの片隅に置かれただけの状態です。
このコマンドを打つことで、以下のような「アプリを動かすための設定」が自動で行われます。

　・設定ファイルの作成: 「config/initializers/devise.rb」という、
　　ログインのルール（パスワードは何文字以上にするか？など）を決めるファイルが作られます。
　　　　同じコマンドを繰り返すと、conflict と出るのは、この設定ファイルを「上書きして作り直そうとしている」からです。

　・多言語対応ファイルの作成: ログインエラー時のメッセージ（「パスワードが違います」など）を管理するファイルが作られます。
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――



２．Userモデルの作成　※コミット名は「usersテーブルの作成」

　・ターミナル上で「rails g devise user」とコマンドする。
　　マイグレーションファイル、Userモデル（app/models/user.rb）、
　　ルーティング設定（devise_for :users）をまとめて自動処理できる。

　・usersテーブルに追加するカラムを記述する。
　　　・自動生成されたマイグレーションファイルを「rails db:migrate」する前に、
　　　　直接ファイル内にてchangeメソッドの「create_table :users do |t|」の中に、
　　　　「t.string :name, null: false」と打ち込む。
　　　
　　　・直接打ち込まない場合は、
　　　　自動生成時のまま上記ファイルをマイグレイト後、追加用のマイグレーションファイルを作成し、
　　　　ファイル内にてchangeメソッドの「add_column :users, :name, :string」以降に追記してから
　　　　マイグレイトを行う。
　　　　その際は、「rails g migration AddNameToUsers name:string」とターミナル上でコマンドして
　　　　追加用のマイグレーションファイルを作成する。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
＊＊「rails g devise user」の意味＊＊

「ユーザー（利用者）」という概念をシステムの中に実際に作り出すコマンドです。
「rails g devise:install」が「アプリ全体の共通設定」だったのに対し、
「rails g devise User」は**「具体的なデータ保存の仕組み」**を作ります

　　【3つの大きな役割】
このコマンドを叩くと、主に以下の3つの変化がアプリに起こります。

1. データベースの設計図（マイグレーションファイル）の作成
　　　ユーザーの「メールアドレス」や「暗号化されたパスワード」を保存するための、
　　　データベースのテーブル（表）を作るための指示書が作成されます。

2. ユーザーモデル（User.rb）の作成
　　　「app/models/user.rb」というファイルが作られます。
　　　ここには「パスワードは6文字以上」「メールアドレスは必須」といった、ユーザーに関するルールが書き込まれます。

3. ルーティング（URL）の自動設定
　　　config/routes.rb に devise_for :users という一行が追加されます。
　　　これにより、以下のURLが自動的に使えるようになります。

　　　　　・「/users/sign_in」（ログイン画面）

　　　　　・「/users/sign_up」（新規登録画面）

　　　　　・「/users/password/new」（パスワード再設定画面）
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
＊＊「devise_for :users」の意味＊＊

「deviseが提供する認証機能（ログイン、新規登録など）に必要なURLをまとめて自動で設定してくれる魔法の呪文」である。

　devise は、ユーザー認証に関するたくさんの機能を提供してくれます。
　「devise_for :users」という一行を「config/routes.rb」に書くだけで、
　以下のような機能に対応するURL（ルーティング）が自動的にアプリケーションに追加されます。

　　・新規登録画面: /users/sign_up
　　・ログイン画面: /users/sign_in
　　・ログアウト処理: /users/sign_out
　　・パスワード再設定画面: /users/password/new
　　・アカウント情報編集画面: /users/edit

・追加しないとどうなるか？

　ルーティング設定に「devise_for :users」がないと、Railsアプリケーションは、
　devise関連のURLを一切知らないままになる。ビューにもアクセスできなくなる（Routing Error）。

　　１．URLにアクセスできなくなる

　　　　　ブラウザで「http://localhost:3000/users/sign_up」にアクセスしても、「そんなURLはありません」というエラー（Routing Error）になってしまう。


　　２．パスヘルパーが使えなくなる

　　　　 ビューファイルなどで「link_to '新規登録', new_user_registration_path」のようにリンクを作ろうとしても、
　　　　　「new_user_registration_path」というメソッド自体が存在しないため、「undefined method」エラーが発生します。


・まとめ
　devise_for :users は、deviseの認証機能をアプリケーションに組み込むための「入口」を作る、絶対に不可欠な設定です。
　これがないと、deviseが提供する便利なログイン画面や新規登録画面にアクセスすることすらできなくなってしまいます。
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――



３．deviseのビュー用意　※コミット名は「deviseに関するビューファイルの配置」

　今回はスクールから提供されたHTML・CSSのビューファイルをダウンロードしたので割愛する。
　なので、今回のChatAppというチャット機能アプリの作成においては、ビューはフロント以外はすべて出来上がったものが揃っていることになり、
　あとは、操作や機能の導入のみを行う。

　・サインアップ（新規ユーザー登録）の画面　「http://localhost:3000/users/sign_up」

　・ログインの画面　「http://localhost:3000/users/sign_in」


４．サインアップ・ログイン機能の実装　※コミット名は「ユーザー認証機能の実装」

まず、ログインしていない場合はログイン画面に繊維する記述をする。

　・「authenticated_user!」メソッド
　　
　　ログイン状態によって表示するページを切り替えるdeviseメソッドのこと。
　　このメソッドは、処理が呼ばれた段階で、ユーザーがログインできていなければ、
　　そのユーザーをログイン画面に遷移させる。
　　このこの仕組みを利用し、before_actionで呼び出すことで、
　　アクションを実行する前にログインしていなければログイン画面に遷移させる。
　　「application_controller.rb」にて、「before_action :authenticate_user!」と記述する。


　・ユーザーの名前をDBへ保存できるように設定

　　サインアップ時に、ユーザーの名前を登録できるように「application_controller.rb」を編集する。
　　「before_action :authenticate_user!」の下に、

　　「before_action :configure_permitted_parameters, if: :devise_controller?

  private

  　def configure_permitted_parameters
    　devise_parameter_sanitizer.permit(:sign_up, keys: [:name])
  　end」と記述する。


  こうすることで、deviseのコントローラーから呼び出された場合は、すべてのアクションが実行される前に、
  「authenticated_user!」メソッド、「configure_permitted_parameters」メソッドが呼び出され実行される。
  
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
＊＊「configure_permitted_parameters」とは？＊＊

    「Deviseが管理するフォームで、自分で追加したパラメーター（今回は:name）のデータ操作を許可する」ためのメソッドです。

・なぜ必要か？

　Deviseはセキュリティをとても重視しています。そのため、初期状態では email、password、password_confirmation といった、
　Deviseが元々知っているパラメーターしか受け付けないように作られています。
　これは、悪意のあるユーザーが予期しないデータを送りつけて、データベースを壊したり情報を盗んだりするのを防ぐためです（Railsの「Strong Parameters」という仕組みです）。

　そのため、サインアップ画面に name の入力欄を追加しただけでは、そのデータは無視されてしまい、データベースに保存されません。
  「configure_permitted_parameters」メソッドで「 name というパラメーターも受け取って保存して良いですよ」と明示的に許可してあげる必要があります。


・コードの解説

  ・「before_action :configure_permitted_parameters, if: :devise_controller?」

　　　「devise_controller?」は、Devise関連のコントローラーが動作しているときだけ true になるヘルパーメソッドです。
　　　「if: :devise_controller?」という条件のおかげで、サインアップやログインなど、Deviseに関係する画面が開かれたときだけ
　　　「configure_permitted_parameters」メソッドは実行されます。
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
＊＊「devise_parameter_sanitizer」とは？＊＊

　　　Devise専用の「ストロングパラメーター」の門番です。
　　　Railsには、セキュリティのために意図しないパラメーターがデータベースに保存されるのを防ぐ「ストロングパラメーター」という仕組みがあります。
　　　「devise_parameter_sanitizer」は、その仕組みをDeviseのコントローラー（新規登録、ログイン、アカウント更新など）で簡単に使えるようにしたものです。

  ・devise_parameter_sanitizer.permit(:sign_up, keys: [:name])

　　　「devise_parameter_sanitizer」は、これからDeviseのパラメーターをチェックしますよ、という合図です。
　　　また、「.permit」では、第一引数 「(:sign_up):」で、どの操作のときかを指定します。

　　　　・「:sign_up」は、新規ユーザー登録という意味。
　　　　・「sign_in」は、ログイン
　　　　・「:account_update」は、アカウント情報更新

    　そして、第二引数 (keys: [:name]): 許可したいパラメーターの名前を配列で指定します。
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――




５．ユーザー情報編集機能の実装　※コミット名は「ユーザー編集機能の実装」

　ユーザー情報を登録後に編集できる機能を追加する。
　ユーザーの名前とメールアドレスを更新できるようにする。

　・ ユーザー編集画面が表示されるように設定する

　　　ルーティング設定は、「resources :users, only: [:edit, :update]」と記述する。
　　　次に、コントローラーはユーザーに関するものなので、うっかり messages コントローラーで作業せず、
　　　ターミナル上で「rails g controller users」で users コントローラーを作成。
　　　users コントローラー内で editアクションを定義する。


　・ユーザー情報が更新されるように実装する

　　　編集内容が更新できるように、コントローラーに処理を追加する
　　　Userモデルの更新を行う「updateアクション」を定義する。
　　　更新に当たっては、deviseモデルにて自動生成されたヘルパーメソッド「current_user」がユーザー情報の橋渡しを行う。
　　　そして、ストロングパラメーター含まれる「user_params」メソッドを定義する。
　　　メソッド内では、permit メソッドを使用し、カラム「name」、「email」の編集許可を出す。


　・更新に失敗した時、編集画面に戻るようにする　　「render」メソッドの導入

　　　現時点では更新成功した際に何も表示が変わらないので、更新できたのかわかりづらい。
　　　そのため、いまは、更新に失敗したときの表示を設定することで見わけをつける。

　　　「render」メソッドは、呼び出すビューファイルを指定するものである。
　　　renderメソッドには、コントローラーで使用するものと、ビューで使用するものというふうに、
　　　それぞれ異なる機能を持った同名のメソッドがあるけれども、
　　　ここでは、コントローラーで使用するrenderメソッドを用いる。

　　　今回は、ユーザー情報が更新されなかった場合に、フォームに入力した内容を保持したままユーザー編集画面に戻るという処理になります。
　　　多くの場合、render メソッドはデータの保存や更新などに失敗した場合に使用されます。　
　　　そのため、以下のように発生したエラーを指定して使用します。

　　　　　render :edit, status: :unprocessable_entity

　　　ここで指定している「:unprocessable_entity」が、発生したエラーの種類を示すもので、「何らかの処理に失敗した」という汎用的な指定方法になります。
　　　特にエラーの種類を限定したい場合以外は、この「:unprocessable_entity」を使用すると覚えておいて問題ありません。


　　　※重要な点として、Rails 7.0.0以降でアプリケーションを作成した場合、
　　　　renderメソッドにエラーの種類を指定しないと、返される結果が意図したものにならないことがあります。
　　　　そのため、必ずエラーの種類を指定するようにしましょう。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
　・「render」メソッドと「redirect_to」の違い

　　　いずれも、実行するとビューが表示されるけれども、表示までの経路が異なる。
　　　redirect_to は、新たなリクエストを送信されたときと同じ動きになるので、
　　　再度、表示までにルーティング、コントローラーを経由するのに対し、
　　　render は、新たにリクエストされることなく直接ビューへ飛ぶ。
　　　これによって、元のインスタンス変数の値が上書きされるかどうかが異なる。

　　　今回は、ユーザー情報が更新されなかった場合に、
　　　フォームに入力した内容を保持したままユーザー編集画面に戻るという処理になります。


    ・「redirect_to」: ブラウザに「もう一度、このURLにアクセスし直してください」と指示を出す。
         ・動き: update アクションが終了 → ブラウザが edit アクションのURLへ再度アクセス → edit アクションが実行され、
         　　　　データベースから最新のユーザー情報（変更前の情報）を読み込み直す → edit のビューが表示される。
         ・結果: フォームに入力した内容が消えて、元の状態に戻ってしまう。

　　　　　　　updateアクションは「ブラウザさん、もう一度 /users/〇〇/edit のページにアクセスし直して！」と指示します。
　　　　　　　ブラウザは言われた通り、もう一度 edit ページをリクエストします。
　　　　　　　サーバー側では、editアクションが動き、データベースからユーザー情報（変更前の正しい情報）を読み込み直します。
　　　　　　　結果、ユーザーが入力した間違った内容（空欄の名前）は消えてしまい、元の名前が表示された編集画面に戻ります。
　　　　　　　これでは、ユーザーはどこを間違えたのか分からず、もう一度入力し直さなければなりません。


    ・「render」: update アクションの中で、別のビューファイル（今回は「edit.html.erb」）を直接呼び出して表示する。
         ・動き: update アクションは終了せず、処理を引き継いだまま edit のビューを表示する。
         ・結果: update アクションで使っていた「バリデーションに失敗したユーザー情報（@user）」をそのままビューで使える。
         　　　　そのため、フォームに入力した内容を保持したまま、エラーメッセージを表示できる。

         　　render を使うと…
　　　　　　　updateアクションは「ページを移動せず、このまま edit の画面を表示しよう」と動きます。
　　　　　　　updateアクションの中で使っていた**「バリデーションに失敗した情報（空欄の名前が入った @user）」を保持したまま**、editの画面を描画します。
　　　　　　　結果、ユーザーが入力した内容がフォームに残ったまま、エラーメッセージと共に編集画面が表示されます。
　　　　　　　ユーザーはどこを直せばいいか一目で分かります。


     **まとめ**
     更新失敗時に`render`を使うことで、ユーザーが入力した内容を消さずに「ここが間違っていますよ」と教えてあげられる、親切な作りにすることができます。
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――



６．ビューにリンクを実装　※コミット名は「ユーザー情報表示の実装」

　　現状の実装では、以下の未対応の箇所があります。

　アプリケーション内でページ間の遷移ができない
　表示されているユーザー名が仮データである

　・サイドバーからユーザー編集ページへ遷移できるように実装

　　暫定的に配置していた「<a href="#">Tom</a>」を、
　　「<%= link_to current_user.name, edit_user_path(current_user) %>」に変更する。



７．ログアウト機能の実装　※コミット名は「ログアウト機能の実装」

　ユーザー編集画面にlink_toを記述して、アプリケーションからログアウトができるように実装する。

　link_toのパスを、「destroy_user_session_path」と指定します。
　HTTPメソッドの「delete」を指定するため「data: { turbo_method: :delete }」と記述すると、
　ログイン時に使用される devise の sessions コントローラーの destroy アクションが実行されます。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
＊＊「data: { turbo_method: :delete }」とは？＊＊

　「見た目はただのリンクなのに、DELETEリクエストとして送信するための魔法の呪文」です。

　・なぜ必要なのか？

１．Railsのルール

　　「セッションを破棄してログアウトする」という処理は、情報を削除する系統の操作です。
　　Railsでは、このような「削除」にあたる処理は DELETE というHTTPメソッドで行うのがお作法です。
　　routes.rb を見ても、ログアウトのルートは DELETE メソッドで待機しています。




２．ブラウザのルール

　　しかし、ブラウザのリンク（<a>タグ）は、クリックしても GET というHTTPメソッドしか送信できません。
　　DELETE メソッドを直接送る能力がないのです。この「Railsが DELETE を待っている」のに
　　「ブラウザのリンクは GET しか送れない」というギャップを埋めるのが、
　　data: { turbo_method: :delete } の役割です。


　link_to に data: { turbo_method: :delete } を付けておくと、
　ユーザーがリンクをクリックした瞬間に、裏側で以下のようなことが高速で行われています。

　　　1.ユーザーが「ログアウト」リンクをクリックします。

　　　2.Railsに標準で入っている Turbo というJavaScriptライブラリが、そのクリックを検知します。

　　　3.Turboは「お、data-turbo-method="delete" が指定されているな」と気づきます。

　　　4.通常のリンクとしての動作（GETリクエスト）を中止します。

　　　5.代わりに、目に見えない隠しフォームをその場で動的に作成します。

　　　6.その隠しフォームを使って、DELETE リクエストをサーバーに送信します。

　　　7.サーバー側では、正しく DELETE リクエストとして受け取られ、
　　　　　Deviseの sessions コントローラーの destroy アクションが実行されます。

　　　8.無事にログアウト処理が完了します。


　　**まとめ**
　「data: { turbo_method: :delete }」を付けないと、ブラウザは GET メソッドでログアウトしようとしてしまい、
　「そんなルートはありません (No route matches [GET] "/users/sign_out")」というエラーになってしまいます。
　この記述は、見た目はただのリンクでありながら、裏側でJavaScriptの力を借りて正しく DELETE リクエストを送信するための、
　現代のRails開発における必須のテクニックです。




――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――



８．バリデーション設定　※コミット名は「バリデーションの設定」

　入力フォームの Name、Email、Password が空のまま[Create Account]をクリックしたとき、
　以下のエラーメッセージが表示されるようにする。

　「1 error prohibited this user from being saved:
　　Name can't be blank」

　「user.rb」にて、「validates :name, presence: true」と記述する。